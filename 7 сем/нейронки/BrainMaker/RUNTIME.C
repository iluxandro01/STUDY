/*****************************************************************************/
/*                                                                           */
/*                              RUNTIME.C                                    */
/*                                                                           */
/*      This file is copyright(c) 1995 California Scientific Software        */
/*          and is licensed by the CSS Runtime License Agreement.            */
/*      See that agreement for details of your rights to use, modify,        */
/* and distribute this file or the executable code generated by this file.   */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/*  This program is a bare-bones forward-only neural network.  It can accept */
/*  up to three command-line arguments, all filenames, corresponding to the  */
/*  file where the weights are stored, the file where the network input is,  */
/*  and the file where the network output should go.  These three filenames  */
/*  default to BrainRTS.mtx, BrainRTS.in, and BrainRTS.out respectively.     */
/*                                                                           */
/*  Modification to this code is suggested for your particular application.  */
/*  Neuron scaling (renormalization, meaning min/max statements) is now      */
/*  implemented.  Pictoral and symbolic fact files are not.                  */
/*                                                                           */
/*****************************************************************************/

#include <stdio.h>
#include <alloc.h>
#include <math.h>

/************************ prototypes for all functions ***********************/

void main( int argc, char **argv );
void ProcessInputs( int argc, char **argv );
void GetNetworkSize();
void AllocateNetwork();
void DeallocateNetwork();
void RunNetwork();
void VectorTransform( float *v1, int len1, int layer, float *v2, int len2 );
float VectorDotProduct( float *v1, int len, float *v2 );
float myexp( float n );
void TransferFunction( float *v, int len );
void ReadMinMax();
void DefaultMinMax();
void ReadWeights();
int ReadFact( FILE *f, float *v, int length, float *min, float *max );
void WriteFact( FILE *f, float *v, int len, float *min, float *max );
double StringToDouble( unsigned char far * );
double GetDouble( FILE * );
void FreeWeights( int layer, int neurons );
int AllocateWeights( int layer, int neurons, int connections );
void ExitProgram( char *errormessage, int errorcode );

/******************************** EMS and XMS ********************************/

#define MaxLayers 8

/* #define EMSXMS    /* uncomment this line to use the EMS/XMS driver */

#ifndef EMSXMS

float **Weights[MaxLayers-1];
#define WeightVector(_layer,_neuron) (Weights[(_layer)][(_neuron)])
#define InitializeMemory(_i) ;

#else

extern float *WeightVector( int layer, int neuron );
extern int InitializeMemory( int kBytesToReserve );

#endif

char WeightsFile[80] = "BrainRTS.net",
     MinMaxFile[80]  = "BrainRTS.net",
     InputFile[80]   = "BrainRTS.in",
     OutputFile[80]  = "BrainRTS.out";

float *Vectors[MaxLayers];
int NumberOfNeurons[MaxLayers];
int NumberOfLayers = 3, Thresholds = 1;

float *Min[2], *Max[2];

void main( int argc, char **argv ) {
         ProcessInputs( argc, argv );
         InitializeMemory( 0 );
         GetNetworkSize();
         AllocateNetwork();
         ReadMinMax();
         ReadWeights();
         RunNetwork();
         DeallocateNetwork();
         ExitProgram( "Done.", 0 );
}

/***************************** Network definition ****************************/

void ProcessInputs( int argc, char **argv ) {
    if( argc > 1 ) {
        strcpy( WeightsFile, argv[1] );
        strcpy( MinMaxFile,  argv[1] );
    }
    if( argc > 2 ) {
        strcpy( InputFile,   argv[2] );
    }
    if( argc > 3 ) {
        strcpy( OutputFile,  argv[3] );
    }
    if( argc > 4 ) {
        strcpy( MinMaxFile,  argv[4] );
    }

    printf( "Reading weights from %s,\n", WeightsFile );
    printf( "reading inputs from %s,\n",  InputFile   );
    printf( "writing outputs to %s,\n",   OutputFile  );
    printf( "reading minmax from %s.\n",  MinMaxFile  );
}

/***************************** Memory management *****************************/

void GetNetworkSize() {
    FILE *f;  int i;  char keyword[128];

    f = fopen( WeightsFile,  "r" );
    do  fscanf( f, " %127s", keyword );
    while( strncmp( keyword, "weights", 7 ) );

    fscanf( f, " %d %d", &NumberOfLayers, &Thresholds );

    for( i=0; i<NumberOfLayers; i++ ) {
        fscanf( f, " %d ", &NumberOfNeurons[i] );
    }
    fclose( f );

    printf( "Network size: %d thresholds,", Thresholds );
    printf( " %d layers, layer sizes:", NumberOfLayers );
    for( i=0; i<NumberOfLayers; i++ ) {
        printf( " %d", NumberOfNeurons[i] );
    }
    printf( "\n" );
}

void AllocateNetwork() {
    int i, j;

    for( i=0; i<NumberOfLayers; i++ ) {
        Vectors[i] = (float *)malloc( ( NumberOfNeurons[i] + Thresholds )
                                      * sizeof(float) );
    }

    Min[0] = (float *)malloc( NumberOfNeurons[0] * sizeof(float) );
    Max[0] = (float *)malloc( NumberOfNeurons[0] * sizeof(float) );
    Min[1] = (float *)malloc( NumberOfNeurons[NumberOfLayers-1] * sizeof(float) );
    Max[1] = (float *)malloc( NumberOfNeurons[NumberOfLayers-1] * sizeof(float) );

    for( i=0; i<NumberOfLayers-1; i++ ) {
        if( !AllocateWeights( i, NumberOfNeurons[i+1], NumberOfNeurons[i] + Thresholds ) ) {
            ExitProgram( "Out of memory!", 1 );
        }
    }
}

void DeallocateNetwork() {
    int i, j;

    for( i=0; i<NumberOfLayers-1; i++ ) {
                  FreeWeights( i, NumberOfNeurons[i+1] );
    }
    for( i=0; i<2; i++ ) {
        free( Min[i] );
        free( Max[i] );
    }
    for( i=0; i<NumberOfLayers; i++ ) {
        free( Vectors[i] );
    }
}

/************************** Neural network operation *************************/

void RunNetwork() {
         FILE *in, *out;  int i, factCount = 0;

    in  = fopen( InputFile,  "r" );
         out = fopen( OutputFile, "w" );
         while( ReadFact( in, Vectors[0], NumberOfNeurons[0], Min[0], Max[0] ) ) {
        for( i=0; i<NumberOfLayers-1; i++ ) {
            VectorTransform( Vectors[i], NumberOfNeurons[i] + Thresholds,
                             i, Vectors[i+1], NumberOfNeurons[i+1] );
            TransferFunction( Vectors[i+1], NumberOfNeurons[i+1] );
        }
        WriteFact( out, Vectors[NumberOfLayers-1],
                        NumberOfNeurons[NumberOfLayers-1], Min[1], Max[1] );
         }
         fclose( in );
    fclose( out );
}

void VectorTransform( float *v1, int len1, int layer, float *v2, int len2 ) {
    int i;  float *w;

    v1[len1-1] = 1.0;                   /* threshold */
    for( i=0; i<len2; i++ ) {
        w = WeightVector( layer, i );
                  *v2++ = VectorDotProduct( v1, len1, w );
         }
}

float VectorDotProduct( float *v1, int len, float *v2 ) {
    float sum;

    sum = 0.0;
    while( len-- ) {
        sum += *v1++ * *v2++;
    }
    return sum;
}

/* sigmoid transfer function definition, hard-coded. */

#define GAIN   1.0
#define HIGH   1.0
#define LOW    0.0 /* bug in released version: was 1.0 */
#define CENTER 0.0

float myexp( float n ) {
    if( n < -10.0 )  n = -10.0;
    if( n > 10.0 )   n = 10.0;
    return exp( n );
}

void TransferFunction( float *v, int len ) {
    while( len-- ) {
        *v = (HIGH - LOW) / ( 1 + myexp( GAIN * ( CENTER - *v ) ) ) + LOW;
        if( *v < LOW ) *v = LOW;  if( *v > HIGH ) *v = HIGH;
        v++;
    }
}

/******************************** I/O routines *******************************/

void ReadMinMax() {
    FILE *f;  int i, size, isOutput, isMax;  double n;  float *v;

    DefaultMinMax();
         f = fopen( MinMaxFile, "r" );
         if( !f )  return;
    while( 1 )  {
        if( !FindKeyword( f, &isOutput, &isMax ) )  break;
        v = isMax ? Max[isOutput] : Min[isOutput];
        size = NumberOfNeurons[ isOutput ? NumberOfLayers-1 : 0 ];
        for( i=0; i<size; i++ ) {
                                n = GetDouble( f ); /* fscanf( f, " %lf ", &n ); */
                                v[i] = n;
        }
    }
    fclose( f );
}

int FindKeyword( FILE *f, int *output, int *max ) {
    char keyword[128];

    while( 1 ) {
        if( feof( f ) )  return 0;
                  fscanf( f, " %127s ", keyword );
        if( !strncmp( "scale", keyword, 5 ) ) {
                                fscanf( f, " %127s ", keyword );
                                if( !strncmp( "input", keyword, 5 ) ) {
                *output = 0;
                if( ReadMinimumOrMaximumKeyword( f, max ) )  return 1;
            } else if( !strncmp( "output", keyword, 6 ) ) {
                *output = 1;
                if( ReadMinimumOrMaximumKeyword( f, max ) )  return 1;
            }
        }
    }
}

int ReadMinimumOrMaximumKeyword( FILE *f, int *max ) {
    char keyword[128];

         fscanf( f, " %127s ", keyword );
    if( !strncmp( "minimum", keyword, 7 ) ) {
        *max = 0;  return 1;
    } else if( !strncmp( "maximum", keyword, 7 ) ) {
                  *max = 1;  return 1;
    }
    return 0;
}

void DefaultMinMax() {
    int i;

    for( i=0; i<NumberOfNeurons[0]; i++ ) {
        Min[0][i] = 0.0;  Max[0][i] = 1.0;
    }
    for( i=0; i<NumberOfNeurons[NumberOfLayers-1]; i++ ) {
        Min[1][i] = 0.0; Max[1][i] = 1.0;
    }
}

void ReadWeights() {
    FILE *f;  int i, j, k, dummy;  double n;  float *w;  char keyword[128];

    f = fopen( WeightsFile, "r" );
    if( !f )  ExitProgram( "Cannot open weight file.", 1 );
         do  fscanf( f, " %127s", keyword );
    while( strncmp( keyword, "weights", 7 ) );

         fscanf( f, " %d %d ", &dummy, &dummy );
    for( i=0; i<NumberOfLayers; i++ ) {
        fscanf( f, " %d ", &dummy );
    }
    for( i=0; i<NumberOfLayers-1; i++ ) {
        for( j=0; j<NumberOfNeurons[i+1]; j++ ) {
            w = WeightVector( i, j );
            for( k=0; k<NumberOfNeurons[i]+Thresholds; k++ ) {
                n = GetDouble( f ); /* fscanf( f, " %lf ", &n ); */
                w[k] = (float)n;
            }
        }
    }
    fclose( f );
}

int ReadFact( FILE *f, float *v, int length, float *min, float *max ) {
         int i;   double temp;

         for( i=0; i<length; i++ ) {
        if( feof( f ) )  return 0;
                  temp = GetDouble( f ); /* fscanf( f, " %lf ", &temp ); */
                  v[i] = ( temp - min[i] ) / ( max[i] - min[i] );
         }
         return 1;
}

void WriteFact( FILE *f, float *v, int len, float *min, float *max ) {
    int i;  double temp;

    for( i=0; i<len; i++ ) {
        temp = v[i] * ( max[i] - min[i] ) + min[i];
        fprintf( f, "%6.3lf ", temp );
    }
    fprintf( f, "\r\n" );
}

static char SpecialChar[11] = "\001\003\004\006\032 \001\003\004\006";
static unsigned char suffixes[] = "**yzafpnum KMGTPEZY!!";

int skipBlanks( unsigned char far *str ) {
    register int i;  register char sep = SpecialChar[5];

    for( i=0; str[i] && ( str[i] <= ' ' || str[i] == sep ); i++ );
    return i;
}

int findWord( unsigned char far *str ) {
    register int i;  register char sep = SpecialChar[5];

    for( i=0; str[i] > ' ' && str[i] != sep; i++ );
    return i;
}

double StringToDouble( unsigned char far *string ) {
         double val;  int i, x;  char savechar;  unsigned char temp[80];

         string += skipBlanks( string );
         savechar = string[ x = findWord( string ) ];
         string[x] = 0;
         _fstrcpy( temp, string );
         val = atof( temp );
         for( i=0; suffixes[i++]; ) {
                  if(  suffixes[i] == temp[x-1] ) {
                                while( i-- > 10 )  val *= 1000.0;
                                while( ++i < 10 )  val /= 1000.0;
                                break;
                  }
         }
         string[x] = savechar;
         return val;
}

double GetDouble( FILE *f )  {
        char s[128];
        fscanf( f, " %127s ", s );
        return StringToDouble( s );
}

#ifndef EMSXMS

int AllocateWeights( int layer, int neurons, int connections ) {
    int i;

    Weights[layer] = (float **)malloc( neurons * sizeof(float *) );
    if( !Weights[layer] )  return 0;
    for( i=0; i<neurons; i++ ) {
        Weights[layer][i] = (float *)malloc( connections * sizeof(float) );
        if( !Weights[layer][i] )  return 0;
    }
    return 1;
}

void FreeWeights( int layer, int neurons ) {
    int i;

    for( i=0; i<neurons; i++ ) {
        free( Weights[layer][i] );
    }
    free( Weights[layer] );
}

#endif

void ExitProgram( char *errormessage, int errorcode ) {
         printf( "%s\n", errormessage );
    exit( errorcode );
}
